<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>Liquid Rainbow Flow Effect</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16/9;
            image-rendering: pixelated; 
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="rainbowCanvas" width="64" height="36"></canvas>

    <script>
        class PerlinNoise {
            constructor() {
                this.p = new Uint8Array(512);
                this.permutation = [
                    151,160,137,91,90,15,
                    131,13,201,95,96,53,194,233,7,225,140,36,103,30,
                    69,142,8,99,37,240,21,10,23,
                    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
                    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,
                    168, 68,175,74,165,71,134,139,48,27,166,
                    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
                    55,46,245,40,244,102,143,54, 65,25,63,161, 1,216,80,73,
                    209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,
                    164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,
                    38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,
                    182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,
                    221,153,101,155,167, 43,172,9,
                    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,
                    218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,
                    81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,
                    184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,
                    222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
                ];
                for (let i = 0; i < 256; i++) {
                    this.p[256 + i] = this.p[i] = this.permutation[i];
                }
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y, z) {
                let h = hash & 15;
                let u = h < 8 ? x : y;
                let v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            noise(x, y, z) {
                let floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);
                let X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

                x -= floorX;
                y -= floorY;
                z -= floorZ;

                let u = this.fade(x);
                let v = this.fade(y);
                let w = this.fade(z);

                let A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z;
                let B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;

                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                                                        this.grad(this.p[BA], x - 1, y, z)),
                                            this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                                                        this.grad(this.p[BB], x - 1, y - 1, z))),
                                this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                                                        this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                                            this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                                                        this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        const perlin = new PerlinNoise();

        const canvas = document.getElementById('rainbowCanvas');
        const ctx = canvas.getContext('2d');

        let time = 0;

        function draw() {
            const width = canvas.width;   
            const height = canvas.height; 
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const scale = 0.02;  
            const speed = 0.001;  

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {

                    const value = perlin.noise(x * scale, y * scale, time);

                    const hue = ((value + 1)) * 360; 

                    const saturation = 100; 
                    const lightness = 50;    
                    const rgb = hslToRgb(hue / 360, saturation / 100, lightness / 100);

                    const index = (x + y * width) * 4;
                    data[index]     = rgb[0];      
                    data[index + 1] = rgb[1];      
                    data[index + 2] = rgb[2];      
                    data[index + 3] = 255;         
                }
            }

            ctx.putImageData(imageData, 0, 0);

            time += speed;
            requestAnimationFrame(draw);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l; 
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        draw();
    </script>
</body>
</html>